<?php
/**
 * @CreateTime:   2021/1/3 1:21 上午
 * @Author:       huizhang  <2788828128@qq.com>
 * @Copyright:    copyright(2020) Easyswoole all rights reserved
 * @Description:  延迟队列进程处理
 */

namespace Huizhang\DelayQueue;

use EasySwoole\Component\Process\Socket\AbstractUnixProcess;
use EasySwoole\Component\Process\Socket\UnixProcessConfig;
use Swoole\Coroutine;
use Swoole\Coroutine\Socket;

class ConsumerProcess extends AbstractUnixProcess
{

    public function __construct(UnixProcessConfig $config)
    {
        /** @var $queue Queue */
        $queue = $config->getArg();
        $number = $queue->getCoroutineNum();
        $targetCacheFile = $this->cacheFileName($queue->getAlias(), 0);
        while (true) {
            $currentCachefile = $this->cacheFileName($queue->getAlias(), $number);
            if (!file_exists($currentCachefile)) {
                break;
            }
            QueueDataLocalCache::getInstance()->mergeAtoBAndUnlinkA($currentCachefile, $targetCacheFile);
        }
        parent::__construct($config);
    }

    public function run($arg)
    {
        /** @var $queue Queue */
        $queue = $arg;
        /** @var $consumer ConsumerAbstract */
        $namespace = "{$queue->getClass()}";
        $consumer = new $namespace;
        $consumer->queue = $queue;
        $consumer->init();
        for ($i = 0; $i < $queue->getCoroutineNum(); $i++) {
            Coroutine::create(function () use ($queue, $consumer) {
                $cacheFile = $this->cacheFileName($queue->getAlias(), $queue->getDelayTime());
                $errorCacheFile = $this->cacheFileName($queue->getAlias(), -1);
                $failTimes = 0;
                while (true) {
                    try {
                        $data = $this->getQueueData($queue);
                        $consumer->deal($data);
                        QueueDataLocalCache::getInstance()->rem($cacheFile, count($data));
                    } catch (\Throwable $e) {
                        ++$failTimes;
                        if ($failTimes > 3) {
                            QueueDataLocalCache::getInstance()->mergeAtoBAndUnlinkA($cacheFile, $errorCacheFile);
                            break;
                        }
                    }
                    Coroutine::sleep(1);
                }
            });
        }
        return parent::run($arg); // TODO: Change the autogenerated stub
    }

    /**
     * 获取队列数据
     *
     * @param Queue $queue
     * @return array
     * CreateTime: 2021/1/17 2:58 上午
     */
    private function getQueueData(Queue $queue)
    {
        $cacheFile = $this->cacheFileName($queue->getAlias(), $queue->getDelayTime());
        $errorCacheFile = $this->cacheFileName($queue->getAlias(), -1);
        $data = QueueDataLocalCache::getInstance()->read($errorCacheFile, $queue->getLimit());
        if (empty($data)) {
            $data = QueueDataLocalCache::getInstance()->read($cacheFile, $queue->getLimit());
        }
        if (empty($data)) {
            $data = Core::getInstance()
                ->pop(
                    $queue->getRedisAlias()
                    , $queue->getAlias()
                    , time() - $queue->getDelayTime()
                    , $queue->getLimit()
                );
            if (empty($data)) {
                QueueDataLocalCache::getInstance()->write($cacheFile, $data);
            }
        }
        return $data;
    }

    private function cacheFileName(string $queueAlias, string $coroutineNumber)
    {
        return sprintf(
            '%squeue_cache/%s_%s.txt'
            , Config::getInstance()->getTempDir(), $queueAlias, $coroutineNumber
        );
    }

    function onAccept(Socket $socket)
    {
        // TODO: Implement onAccept() method.
    }
}
